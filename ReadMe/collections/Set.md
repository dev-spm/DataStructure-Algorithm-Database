# Set - Duplicate values are not allowed- Insertion order not preserved- Collection    - Set        - HashSet            - LinkedHashSet        - SortedSet            - NavigableSet            - TreeSet    - Set interface does not contain any methods, it contains only collection methods- Set (Interface)- Shorted Set (Interface) extends Set- Navigable Set (Interface) extends Shorted Set- TreeSet (Class) Implements Navigable Set- HashSet- LinkedHashSet- ShortedSet## Methods of Set Interface- add(element)	This method is used to add a specific element to the set. The function adds the element only if the specified element is not already present in the set else the function returns False if the element is already present in the Set.- addAll(collection)	This method is used to append all of the elements from the mentioned collection to the existing set. The elements are added randomly without following any specific order.- clear()	This method is used to remove all the elements from the set but not delete the set. The reference for the set still exists.- contains(element)	This method is used to check whether a specific element is present in the Set or not.- containsAll(collection)	This method is used to check whether the set contains all the elements present in the given collection or not. This method returns true if the set contains all the elements and returns false if any of the elements are missing.- hashCode()	This method is used to get the hashCode value for this instance of the Set. It returns an integer value which is the hashCode value for this instance of the Set.- isEmpty()	This method is used to check whether the set is empty or not.- iterator()	This method is used to return the iterator of the set. The elements from the set are returned in a random order.- remove(element)	This method is used to remove the given element from the set. This method returns True if the specified element is present in the Set otherwise it returns False.- removeAll(collection)	This method is used to remove all the elements from the collection which are present in the set. This method returns true if this set changed as a result of the call.- retainAll(collection)	This method is used to retain all the elements from the set which are mentioned in the given collection. This method returns true if this set changed as a result of the call.- size()	This method is used to get the size of the set. This returns an integer value which signifies the number of elements.- toArray()## HashSet- It uses HashMap internally to store data.- If we want to add duplicate object, it will return false. It will not throw any compiletime or runtime error- It will store the values on the basis of hashcode of the object- Heterogeneous objects are allowed- Null value allowed- Serializable and cloneable interface implemented- If our frequent operation is search, then this is recommended- HashMap, HashSet, linkedHashSet, IdentityHAshMap, WeakHashMap, HashTable- HashSet h = new HashSet();- Default capacity 16, load factor/ fill ratio = 0.75```    HashSet h = new HashSet(); // with default initial capacity 16 and default fill ratio 0.75    Fill ratio : after filling 75 % of the original size of HashSet, a new Object with bigger size will create    HashSet h = new HashSet(int initialCapacity); //default fill ratio 0.75    HashSet h = new HashSet(int initialCapacity,float loadFactor); ```## LinkedHashSet- It is child class of HashSet- Introduced in 1.4 version- Same as HashSet except below Difference- If duplicate element now allowed and insertion order must be preserved then we use this.## Difference Between HashSet and LinkedHashSet- HashSet underlying Data Structure is HashTable, but LinkedHashSet’s underlying Data Structure is HashTable and linked List- HashSet not preserved Insertion Order but LinkedHashset preserved Insertion Order- HashSet introduced in 1.2 but LinkedHashSet introduced in 1.4>> LinkedHashSet is the best choice to develop Cache based application where duplicates are not allowed and insertion order must be preserved.## SORTED SET- It is the child interface of set- If we want to represent a group of individual According to some sorting order and duplicate are not allowed then we go for sortedset- If we want to represent a group of individual object as a single Entity where duplicates are not are not allowed but all objects should be inserted according to some sorting order then we should go for sortedSet(I)## SortedSet Specific Methods- sortedSet = [100,101,103,104,107,110,115]- Object first()  // 100- Object last(); // 115- SortedSet headset(Object obj); // less than the obj //headset(104) =  100,101,103- SortedSet tailSet(Object obj); // Greater than and Equal to  the obj //tailSet(104) = 104,107,110,115>> Default natural sorting order for numbers is Ascending order and for String is Alphabetical orderWe can implement these methods only on Sorted Set implemented classes, that is on TreeSet Object>> If we want to add null to a non empty treeset, it will throw  NullPointerException. If we add a null to empty TreeSet , it will not throw any exception, because it is not require any comparison to insert Null.>> if we try to add StringBuffer in treeset, it will create RuntimeException because, it does not have default sorting order>> If we are depending on default natural sorting order then object should be Homogeneous and comparable otherwise we will get classCastException at run time. If the class implements Comparable interface, then that class is Comparable Object.>> String class implements serializable and Comparable, but StringBuffer implements Serializable and CharSequence interface. So we can not add StringBuffer to TreeSet, it will show classCastException>> If a collections.treeSet contains some element , then we try to add null to the TreeSet, it will throw null pointer exception because it can’t compare null with some other element present in the TreeSet.>> We can add null to a empty TreeSet.After adding null to Empty TreeSet ,if we add one more element to the treeset it will throw NullPointerException